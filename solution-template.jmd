---
title: "BEE 4750/5750 Homework 2"
author: "Nathan Follett (njf47)"
date: `j import Dates; Dates.Date(Dates.now())`
weave_options:
    term: true
    results: tex
    cache: off
---

<!-- This setups the environment and installs packages, but doesn't appear in the generated document -->
<!-- You shouldn't need to modify this -->
```julia; echo = false; results = "hidden"
using Pkg
Pkg.activate(".")
Pkg.instantiate()
```

# Problem 1

## Problem 1.1
Using a mass balance at the first waste source, the initial concentration of dissolved oxygen can be calculated:
```math
100,000(7.5) + 10,000(5) = 110,000(C_0) \\
C_0 = 7.27 \quad [mg/L]
```
The same can be done for BOD and NOD:
```math
100,000(5) + 10,000(50) = 110,000(B_0) \\
B_0 = 9.09 \quad [mg/L] \\

100,000(5) + 10,000(35) = 110,000(N_0) \\
N_0 = 7.27 \quad [mg/L]
```

```julia

Pkg.add("Plots")
using Plots

# function docalc(x,u,ka,kc,kn)

# initializing given data for function: 

# river velocity U [km/d]
u = 6 
# saturated oxygen concentration [mg/L]
cs = 10
# intial DO concentration at waste source 1 [mg/L]
c01 = (100000*7.5 + 10000*5)/110000
# initial BOD concentration at waste source 1 [mg/L]
b01 = (100000*5 + 10000*50)/110000
# initial NOD concentration at waste source 1 [mg/L]
n01 = (100000*5 + 10000*35)/110000
# decay rates k [1/d]
ka = 0.55
kc = 0.35
kn = 0.25

# establishing function to calculate dissolved oxygen as a function of x
function docalc(x,u,cs,c01,b01,n01)
# establishing coefficients
a1 = exp(-(ka*x)/u)
a2 = (kc/(ka-kc))*(exp(-kc*x/u)-exp(-ka*x/u))
a3 = (kn/(ka-kn))*(exp(-kn*x/u)-exp(-ka*x/u))
# calculate concentration
c = cs*(1-a1) + c01*a1 - b01*a2 - n01*a3
return c
end

# establishing x (distance) vector and data vector to store values
xvec = range(0,15, length=15)
data1 = zeros(15)
# for loop to iterate through distance vector and evaluate function
for i in 1:15
    data1[i] = docalc(xvec[i],u,cs,c01,b01,n01)
end

# finding new initial DO concentration from data1 vector
c02a = data1[15]
b02a = b01*exp(-kc*15/u)
n02a = n01*exp(-kn*15/u)

c02 = (110000*c02a + 15000*5)/125000
b02 = (110000*b02a + 15000*45)/125000
n02 = (110000*n02a + 15000*35)/125000

# establishing x (distance) vector and data vector to store values
xvec1 = range(0,35, length=35)
data2 = zeros(35)
# for loop to iterate through distance vector and evaluate function
for j in 1:35
    data2[j] = docalc(xvec1[j],u,cs,c02,b02,n02)
end

# plotting data for first 15km
plot(xvec,data1);
#plotting data for next 35 km
plot!(range(15,50, length=35),data2)

# establishing BOD/NOD functions


```

## Problem 1.2

## Problem 1.3

## Problem 1.4

## Problem 1.5

## Problem 1.6

## Problem 1.7

```julia; echo=false
# This block will not show up in compiled output.

using Distributions
using PDMats

# This function samples n correlated variates distributed over 
# Uniform([a[1], a[2]]) and Uniform([b[1], b[2]]) with correlation coefficient
# corr_coef.
function sample_correlated_uniform(n, a, b, corr_coef=0.7)
  mvnorm = MvNormal([0, 0], PDMat([1 corr_coef; corr_coef 1])) # set up a multivariate normal with each marginal variance of 1 and the right correlation
  norm_samples = rand(mvnorm, n)' # sample from the multivariate normal, the marginal distributions are a standard normal
  unif_samples = cdf.(Normal(0, 1), norm_samples) # convert samples to a uniform distribution using the pdf of a standard Normal
  samples = (unif_samples .* [a[2] - a[1] b[2] - b[1]]) .+ [a[1] b[1]]
  return samples
end
```

## Problem 1.8

```

# References